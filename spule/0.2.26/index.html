<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      Home - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  
  <link type="text/css" rel="stylesheet" href="styles/collapse.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li  class="active" >
        <a href="index.html">
          
          
            <svg fill="#0095dd" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      spule docs
    </h3>

    
      <h3>
        Resources
      </h3>
      
        <a href="http://thi.ng/umbrella">@thi.ng/umbrella</a>
      
    

    <h3>Modules</h3><ul><li id="INJECT_HEAD-nav"><a href="module-INJECT_HEAD.html">INJECT_HEAD</a></li><li id="Registration-nav"><a href="module-Registration.html">Registration</a><ul class='methods'><li data-type="method" id="Registration-registerCMD-nav"><a href="module-Registration.html#~registerCMD">registerCMD</a></li><li data-type="method" id="Registration-registerRouterDOM-nav"><a href="module-Registration.html#.registerRouterDOM">registerRouterDOM</a></li><li data-type="method" id="Registration-boot-nav"><a href="module-Registration.html#.boot">boot</a></li></ul></li><li id="Routing-nav"><a href="module-Routing.html">Routing</a><ul class='methods'><li data-type="method" id="Routing-HURLer-nav"><a href="module-Routing.html#.HURLer">HURLer</a></li><li data-type="method" id="Routing-URL__ROUTE-nav"><a href="module-Routing.html#.URL__ROUTE">URL__ROUTE</a></li><li data-type="method" id="Routing-URL_DOM__ROUTE-nav"><a href="module-Routing.html#.URL_DOM__ROUTE">URL_DOM__ROUTE</a></li></ul></li><li id="SET_STATE-nav"><a href="module-SET_STATE.html">SET_STATE</a><ul class='methods'><li data-type="method" id="SET_STATE-createSetStateCMD-nav"><a href="module-SET_STATE.html#.createSetStateCMD">createSetStateCMD</a></li></ul></li><li id="FLIP-nav"><a href="module-FLIP.html">FLIP</a></li><li id="multiplex-nav"><a href="module-multiplex.html">multiplex</a><ul class='methods'><li data-type="method" id="multiplex-multiplex-nav"><a href="module-multiplex.html#.multiplex">multiplex</a></li></ul></li><li id="streams-nav"><a href="module-streams.html">streams</a></li><li id="set$$tate-nav"><a href="module-set$tate.html">set$$tate</a><ul class='methods'><li data-type="method" id="set$$tate-set$$tate-nav"><a href="module-set$tate.html#.set$$tate">set$$tate</a></li></ul></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#FLIPFirst">FLIPFirst</a></li><li><a href="global.html#zIndex">zIndex</a></li><li><a href="global.html#FLIPLastInvertPlay">FLIPLastInvertPlay</a></li><li><a href="global.html#commands_1">commands_1</a></li><li><a href="global.html#task$">task$</a></li><li><a href="global.html#diff_keys">diff_keys</a></li><li><a href="global.html#stringify_type">stringify_type</a></li><li><a href="global.html#msTaskPromiseDelay">msTaskPromiseDelay</a></li><li><a href="global.html#trace$">trace$</a></li><li><a href="global.html#__importDefault">__importDefault</a></li><li><a href="global.html#unfURL">unfURL</a></li><li><a href="global.html#fURL">fURL</a></li><li><a href="global.html#xKeyError">xKeyError</a></li></ul>
  </nav>

  <div id="main">
    

    
      



    

      


  <section class="readme">
    <article>
      <h2>Outline</h2>
<ul>
<li>Intro:
<ul>
<li>Data-oriented javascript framework built from <a href="http://thi.ng/umbrella">@thi.ng/umbrella</a> libraries</li>
<li>Other frameworks:
<ul>
<li>too much boilerplate</li>
<li>too much context switching when adding functionality (directory duck duck goose)</li>
<li>large API surface areas</li>
<li>Poor <a href="">&quot;reasonaboutability&quot;</a></li>
</ul>
</li>
<li>This is simpler:
<ul>
<li>upstream (producers) &amp;&amp; downstream (consumers)</li>
<li>async is built in (no middleware required)</li>
<li>Elm/Flux inspired uni-directional data flow
<ul>
<li>via <a href="">FRP</a> under the hood</li>
<li>direct stream participation opt-in only- i.e., not necessary for common needs</li>
</ul>
</li>
<li>Complex asynchronous action coreography is handled for the user by the framework</li>
<li>Learning curve is basically five function signatures (within Tasks, more later)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>IMAGE(s) of a socket and a light switch. You plug in a light and turn it on with a switch...</li>
</ul>
<ul>
<li>♻ Framework Architecture</li>
</ul>
<h3>Command Keys</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
<th>Role(s)</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sub$</code></td>
<td>String</td>
<td>Topic ID: connects Command to handler</td>
<td>[DP]/[RG]</td>
</tr>
<tr>
<td><code>args</code></td>
<td>Any</td>
<td>Payload or payload function</td>
<td>[AH]</td>
</tr>
<tr>
<td><code>path</code></td>
<td>Any</td>
<td>Lens for global state evolution</td>
<td>[ST]</td>
</tr>
<tr>
<td><code>handler</code></td>
<td>Function</td>
<td>Dispatches on Command (side effects)</td>
<td>[RG]</td>
</tr>
<tr>
<td><code>source$</code></td>
<td>Stream</td>
<td>Upstream Command &quot;Feeder&quot;</td>
<td>[AH]</td>
</tr>
<tr>
<td><code>reso</code></td>
<td>Function</td>
<td>Promise resolution handler</td>
<td>[PR]</td>
</tr>
<tr>
<td><code>erro</code></td>
<td>Function</td>
<td>Promise rejection handler</td>
<td>[PR]</td>
</tr>
</tbody>
</table>
<p>parse_URL constants</p>
<table>
<thead>
<tr>
<th>URL component key</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>DOM</td>
<td>DOM node target</td>
</tr>
<tr>
<td>URL</td>
<td>full URL/route</td>
</tr>
<tr>
<td>URL_path</td>
<td>route path as array</td>
</tr>
<tr>
<td>URL_domain</td>
<td>top-level domain as array</td>
</tr>
<tr>
<td>URL_subdomain</td>
<td>subdomain as array</td>
</tr>
<tr>
<td>URL_query</td>
<td>node querystring parsed URL parameters</td>
</tr>
<tr>
<td>URL_hash</td>
<td>hash string to/from URL if any</td>
</tr>
<tr>
<td>URL_data</td>
<td>data returned by router</td>
</tr>
<tr>
<td>URL_page</td>
<td>page component to render URL_data with</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>router config key</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>HEAD</td>
<td>metadata wrapper for router (targets DOM <head>)</td>
</tr>
<tr>
<td>BODY</td>
<td>data wrapper for router</td>
</tr>
<tr>
<td>prep</td>
<td>pre-router behavior Task/Command injection</td>
</tr>
<tr>
<td>post</td>
<td>post=router behavior Task/Command injection</td>
</tr>
<tr>
<td>prefix</td>
<td>URL path string for the router to ignore</td>
</tr>
<tr>
<td>router</td>
<td>@thi.ng/EquivMap pattern matching function</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Command key</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>sub$</td>
<td>Command primary/unique key (topic subscription)</td>
</tr>
<tr>
<td>args</td>
<td>multiple signature intra-Task Command state see <a href="">Spule</a></td>
</tr>
<tr>
<td>reso</td>
<td>intra-Command resolver of Promise args</td>
</tr>
<tr>
<td>erro</td>
<td>intra-Command handler for Promise args rejetions</td>
</tr>
<tr>
<td>handler</td>
<td>where Commands' actual &quot;work&quot; is done (side-fx/mutations)</td>
</tr>
<tr>
<td>source$</td>
<td>upstream (source stream) Command connector</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>boot config key</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>run</td>
<td>primary userland dispatch function</td>
</tr>
<tr>
<td>state</td>
<td>global immutable state container</td>
</tr>
<tr>
<td>root</td>
<td>DOM mount node for application</td>
</tr>
<tr>
<td>app</td>
<td>root application view</td>
</tr>
<tr>
<td>trace</td>
<td>enable logging of every global state update</td>
</tr>
<tr>
<td>draft</td>
<td>state shape scaffolding</td>
</tr>
</tbody>
</table>
<h5>RG: Command <em>Registration</em></h5>
<h5>DP: Command <em>Dispatch</em></h5>
<h5>PR: Commands Containing <em>Promises</em> (during dispatch)</h5>
<h5>AH: <em>Ad-hoc</em> Configuration of Command Dispatch</h5>
<h5>ST: Global <em>State</em> evolution (lens)</h5>
<p><a href="">lensed</a></p>
<h3>Symbols Glossary</h3>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(#) =&gt;</code></td>
<td>[function with <code>#</code> (number) parameters]</td>
</tr>
<tr>
<td><code>PRI</code></td>
<td>Primitive value (boolean, string, number)</td>
</tr>
<tr>
<td><code>{?}</code></td>
<td>Object</td>
</tr>
<tr>
<td><code>{P}</code></td>
<td>Promise</td>
</tr>
<tr>
<td><code>{C}</code></td>
<td>[Command object]</td>
</tr>
<tr>
<td><code>{A}</code></td>
<td>[Accumulator object]</td>
</tr>
<tr>
<td><code>[{C},{C}]</code> / <code>[T]</code></td>
<td>[Task array]</td>
</tr>
<tr>
<td><code>(A) =&gt; [T]</code></td>
<td>[Subtask]</td>
</tr>
</tbody>
</table>
<p><a href="#intra-task-accumulator">function with <code>#</code> (number) parameters</a>
<a href="#commands">Command object</a><br>
<a href="#intra-task-accumulator">Accumulator object</a><br>
<a href="#tasks">Task array</a><br>
<a href="#subtasks">Subtask</a></p>
<ul>
<li>
<p>Commands</p>
</li>
<li>
<p>Tasks</p>
</li>
<li>
<p>Subtasks</p>
</li>
<li>
<p>Intra-Task Accumulator</p>
<ul>
<li>Cross-platform router</li>
<li>❤ Data &quot;adornment&quot; (Google Doc -&gt; revise it) TABLE
<ol>
<li>First order UI =&gt; URL</li>
<li>Second order UI =&gt; Data</li>
<li>Third order UI =&gt; Streams of events &amp; data</li>
<li>Fourth order UI =&gt; Componentization (<a href="https://github.com/thi-ng/umbrella/blob/a02d7b1dbea4e4a294d238af108d23ec831c1981/packages/transducers/src/func/deep-transform.ts">@thi.ng/hdom</a> <code>spec</code>)</li>
<li>Fith order UI =&gt; component styling (styled-system-hdom)</li>
</ol>
</li>
</ul>
</li>
<li>
<p>streams (FRP Architecture)</p>
<ul>
<li>marble diagram</li>
<li>built-ins (exposed):
<ul>
<li><code>run$</code></li>
<li><code>out$</code></li>
</ul>
</li>
<li>built-ins (under the hood):
<ul>
<li><code>task$</code></li>
<li><code>command$</code></li>
</ul>
</li>
<li>ad-hoc stream attachments
<ul>
<li>SEE ADVANCED SECTION BELOW...</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Commands (synchronous payloads)</p>
<ul>
<li>primary keys: (TABLE)
<ul>
<li><code>sub$</code>: a Topic key for for registering the event</li>
<li><code>args</code>: arguments for the handler of the event</li>
<li><code>path</code>: path/lens for targeted state evolution</li>
</ul>
</li>
<li>built-ins
<ul>
<li>State Evolution: <code>sub$: &quot;STATE&quot;</code>
<ul>
<li>this is where the <code>path</code> key comes into play</li>
</ul>
</li>
<li>Routing: <code>sub$: &quot;ROUTE&quot;</code> (see &quot;Routing&quot; section below)</li>
<li><a href="">FLIP</a> Animations: <code>sub$: &quot;FLIP&quot;</code></li>
</ul>
</li>
<li>Command Registration
<ul>
<li>during registration of a Command, you will only need the primary keys
<ul>
<li><code>sub$</code>: Topic key for for registering the event</li>
<li><code>args</code>: payload (static only) of the event</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Tasks (ordered Command dispatch 💃 asynchronous payloads!)</p>
<ul>
<li>A Task is just an array of Commands, but with some special features:
<ul>
<li>pass data between Commands within a task</li>
<li>use Promises (async) in a Command</li>
<li>(de)compose a Task into/from Subtasks</li>
</ul>
</li>
<li>w/in a Task, dispatcher recognizes two additional keys for dealing with Promises:
<ul>
<li><code>reso</code>: used for handling resolved Promise args</li>
<li><code>erro</code>: used for handling rejected Promise args</li>
</ul>
</li>
<li>dispatcher
<ul>
<li>composition of Commands</li>
<li>&quot;Command <code>args</code> threading&quot;</li>
<li><code>args</code> signature dynamic dispatch:
<ul>
<li>Functions</li>
<li>Objects</li>
<li>Strings|Booleans</li>
</ul>
</li>
</ul>
</li>
<li>forms:
<ul>
<li>formulaic tasks (no outside input)</li>
<li>subtasks (outside input)
<ul>
<li>compose into higher-order tasks or</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>subtasks</p>
</li>
<li>
<p>Routing</p>
<ul>
<li>combine browser API instigated (&quot;popstate&quot;, &quot;DOMContentLoaded&quot;) with user-invoked stream emissions</li>
<li>registered the <code>sub$: &quot;ROUTE&quot;</code> Command</li>
<li><code>route_cfg</code> Object (TABLE)
<ul>
<li>a <a href="http://thi.ng/associative">@thi.ng/associative</a> <code>EquivMap</code> pattern matcher</li>
<li>see [LINK TO DOCS IN CODE CONTEXT 📌 TODO]</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Naming Conventions:</p>
<ul>
<li>constants: <code>CAPITAL_SNAKE_CASE</code>
<ul>
<li>generally accepted convention for constants in JS</li>
<li>used for defining Commands (as though they might cause
side effects, their subscription names are constant -
i.e., a signal for emphasising this aspect of a
Command)</li>
</ul>
</li>
<li>pure functions: <code>snake_case</code>
<ul>
<li>some novelty here due to pure functions acting like
constants in that with the same input they always
return the same output</li>
</ul>
</li>
<li>impure functions: <code>camelCase</code>
<ul>
<li>regular side-effecty JS</li>
</ul>
</li>
<li>Tasks: <code>DOUBLE__UNDERSCORE__SNAKE__CASE</code>
<ul>
<li>implies the inputs and outputs on either end of a Task</li>
<li>Tasks also should be treated as pure functions where
the output is really just data (and lambdas). This is
going in the direction of &quot;code as data&quot;</li>
</ul>
</li>
</ul>
</li>
<li>
<p>lots'o'examples</p>
</li>
</ul>
<h2>Commands</h2>
<pre class="prettyprint source lang-js"><code>const genie = {
  sub$: &quot;GENIE&quot;,
  args: &quot;your wish&quot;
  work: x => console.log(&quot;🧞:&quot;, x, &quot;is my command&quot;)
}

const GENIE = registerCMD(genie)

run(GENIE)
// 🧞: your wish is my command
</code></pre>
<p>A Command object can have four keys:</p>
<ol>
<li><code>sub$</code> (required)</li>
<li><code>args</code> (optional, sets default) during registration</li>
<li><code>work</code> (required)</li>
<li><code>src$</code> (optional, enables stream to feed Command)</li>
</ol>
<h2>Core</h2>
<p>Handles Collections (array) of Commands (&quot;Tasks&quot;) which
require <em>ordered</em> choreography and/or have a dependency
on some (a)sync data produced by a user interaction.</p>
<h3>Synopsis:</h3>
<ul>
<li>Async <code>reduce</code> function, that passes an accumulator
(<code>acc</code>) as a local state container between Command
invocations.</li>
<li>Commands are composed in-situ in userland (Ad hoc)</li>
<li>spools a collection of Commands as a Task</li>
<li>resolves any promises contained within a Command</li>
<li>passes an accumulator (acc) to subsequent Commands in a
Task</li>
</ul>
<h3>Type checks on function signatures</h3>
<p>There are two valid forms for Task entries:</p>
<ol>
<li>a Unary function returning an array of Commands:
referred to as &quot;Subtasks&quot;</li>
<li>A Command object: dispatch to registered handlers</li>
</ol>
<h2>Recognized Keys</h2>
<p>There are 4 recognized keys for a Command object:</p>
<h3>Primary keys</h3>
<h5><code>sub$</code> key</h5>
<ul>
<li>Topic identifier: used for registering handlers hooked
onto the Command stream.</li>
</ul>
<h5><code>args</code> key</h5>
<ul>
<li><strong>primary control structure</strong> with three recognized
forms that do different things in the context of a
Task:</li>
<li>non-function <code>args</code> (primitives, objects) send the args
as-is to the Command handler</li>
<li>nullary fns (<code>(0)=&gt;</code> ) send the args_ as a Command to
a <code>sub$</code> <em>stream</em> of your choosing (ADVANCED: see
Ad-hoc Stream Injection below)</li>
<li>unary fns (<code>(1)=&gt;</code>) are passed the inter-Task
accumulated value, called and the resulting value is
passed to registered Command handler</li>
<li>Promises (and those returned from <code>(1)=&gt;</code>) are resolved
and their values sent to the handler</li>
<li>new vals (Objects) are merged with accumulated object
from preceding Task results(dupe keys overwritten)</li>
</ul>
<h3>Promise-specific keys -&gt; binary (as in two parameter,</h3>
<p>not boolean) functions:</p>
<h5><code>reso</code> key</h5>
<ul>
<li>(resolving) function <code>(2)=&gt;</code> = handle resolved promises:
MUST be a binary fn <code>(acc, resolved Promise) =&gt;</code></li>
</ul>
<h5><code>erro</code> key</h5>
<ul>
<li><code>(2)=&gt;</code> = handle rejected promises: MUST be
a binary fn <code>(acc, Promise rejection) =&gt;</code></li>
</ul>
<h3>Subtasks:</h3>
<p>Subtasks are the way you compose tasks. Insert a Task and
the spool will unpack it in place (super -&gt; sub
order preserved) A Subtask must be defined as a unary
function that accepts an accumulator object and returns a
Task, e.g.:</p>
<h4>PSEUDO</h4>
<pre class="prettyprint source lang-js"><code>// { C: Command }
// ( { A: Accumulator }: Object ) => [{C},{C}]: Subtask
let someSubtask = ({A}) => [{C}, {C}, ({A})=>[{C},{C}], ...]
</code></pre>
<h4>Example</h4>
<pre class="prettyprint source lang-js"><code>// subtask example:
let subtask1 = acc => [
 { sub$: &quot;acc&quot;
 , args: { data: acc.data } },
 { sub$: &quot;route&quot;
 , args: { route: { href: acc.href } } }
]
// task
let task = [
 { args: { href: &quot;https://my.io/todos&quot; } }, // acc init
 { sub$: &quot;fetch&quot;
 , args: ({ href }) => fetch(href).then(r => r.json())
 , erro: (acc, err) => ({ sub$: &quot;cancel&quot;, args: err })
 , reso: (acc, res) => ({ data: res }) },
 acc => subtask1(acc), // subtask reference
 { sub$: &quot;FLIP&quot; , args: &quot;done&quot; }
]
</code></pre>
<h3>Ad-hoc stream injection</h3>
<ul>
<li>ADVANCED
<ul>
<li>ad-hoc stream injection
<ul>
<li>nullary (thunk) in a Task</li>
</ul>
</li>
<li><code>rendertron</code>
ADVANCED USE ONLY 👽</li>
</ul>
</li>
</ul>
<p>HURL tries to hide the stream implentation from the user
as much as possible, but allows you to go further down
the rabbit hole if so desired. You may send Commands to a
separate stream of your own creation during a Task by
using a nullary (&quot;thunk&quot;) <code>(0)=&gt;</code> function signature as
the <code>args</code> value of a Command. If this is the case, the
spool assumes the <code>sub$</code> key references a stream and
sends the return value of the thunk to that stream
This feature can come in handy for &quot;fire and forget&quot;
events (e.g., logging, analytics, etc.)</p>
<blockquote>
<p>Note: if you need to pass the accumulator to your
thunk, put it in a subtask, where you can
access/destructure the data from the acc passed into the
subtask function</p>
</blockquote>
<pre class="prettyprint source lang-js"><code>import { stream } from &quot;@thi.ng/rstream&quot;
import { map, comp } from &quot;@thi.ng/transducers&quot;
// ad-hoc stream
let login = stream().subscribe(comp(
 map(x => console.log(&quot;login ->&quot;, x)),
 map(({ token }) => loginToMyAuth(token))
))
// subtask
let subtask_login = ({ token }) => [
 { sub$: login // &lt;- stream
 , args: () => ({ token }) } // &lt;- use acc
]
// task
let task = [
 // no sub$, just pass data
 { args: { href: &quot;https://my.io/auth&quot; } },
 { sub$: login , args: () => &quot;logging in...&quot; },
 { sub$: &quot;AUTH&quot;
 , args: ({ href }) => fetch(href).then(r => r.json())
 , erro: (acc, err) => ({ sub$: &quot;cancel&quot;, args: err })
 , reso: (acc, res) => ({ token: res }) },
 acc => subtask_login(acc),
 { sub$: login , args: () => &quot;log in success&quot; }
]
</code></pre>
<h2>Stream Architecture:</h2>
<p><code>run$</code> is the primary event stream exposed to the user
via the <code>ctx</code> object injected into every <code>hdom</code> component
the command stream is the only way the user changes
anything in <code>hurl</code></p>
<h3>Marble Diagram</h3>
<pre class="prettyprint source"><code>0>- |------c-----------c--[~a~b~a~]-a----c-> : calls
1>- |ps|---1-----------1----------0-1----1-> : run$
2>- |t0|---------a~~b~~~~~~~~~~~a~*--------> : task$
3>- |t1|---c-----------c------------a----c-> : command$
4>- ---|ps|c-----a--b--c--------a---a----c-> : out$
Handlers
a>- ---|ta|------*--------------*---*------> : registerCMD
b>- ---|tb|---------*----------------------> : registerCMD
c>- ---|tc|*-----------*-----------------*-> : registerCMD
</code></pre>
<h3>Streams</h3>
<ul>
<li><code>0&gt;-</code>: <code>ctx.run$.next(x)</code> userland dispatches</li>
<li><code>1&gt;-</code>: <code>pubsub({ topic: x =&gt; x.length === 0 })</code> <code>run$</code>
stream</li>
<li><code>2&gt;-</code>: pubsub = <code>false</code> ? -&gt; <code>task$</code> stream</li>
<li><code>3&gt;-</code>: pubsub = <code>true</code> ? -&gt;<code>command$</code> stream</li>
<li><code>4&gt;-</code>: <code>pubsub({ topic: x =&gt; x.sub$ })</code>: <code>out$</code> stream -&gt;
<code>register_command</code></li>
</ul>
<h3>Handlers</h3>
<p><code>4&gt;-</code> this is the stream to which the user (and
framework) attaches handlers. Handlers receive events
they subscribe to as topics based on a <code>sub$</code> key in a
Command object.</p>
<h4>Handlers (framework provided):</h4>
<ul>
<li>&quot;state&quot;: Global state mutations</li>
<li>&quot;route&quot;: Routing</li>
<li>&quot;FLIP&quot; :
<a href="https://aerotwist.com/blog/flip-your-animations/">F.L.I.P.</a>
animations</li>
</ul>
<h3><code>run$</code></h3>
<p>User-land event dispatch stream</p>
<p>This stream is directly exposed to users via <code>ctx</code> Any
one-off Commands <code>next</code>ed into this stream are sent to
the <code>command$</code> stream. Arrays of Commands (Tasks) are
sent to the <code>task$</code> stream.</p>
    </article>
  </section>


    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>